from PyQt5.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QTableWidget, QTableWidgetItem, 
    QPushButton, QLabel, QHeaderView, QMessageBox, QComboBox, QLineEdit,
    QSpinBox, QDoubleSpinBox, QFrame, QCheckBox, QDialog
)
from PyQt5.QtCore import Qt
from PyQt5.QtGui import QPixmap
from models.product import Product
from models.category import Category
import json
import os

class ProductManagementWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.init_ui()
        self.load_products()

    def init_ui(self):
        """Initialize the user interface"""
        self.setWindowTitle("Gestion des produits")
        self.setGeometry(100, 100, 1200, 800)

        # Main layout
        main_layout = QVBoxLayout(self)

        # Search and filter section
        top_layout = QHBoxLayout()
        
        # Search box
        search_label = QLabel("Rechercher:")
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Nom de produit, code-barres...")
        self.search_input.textChanged.connect(self.filter_products)
        
        # Category filter
        category_label = QLabel("Catégorie:")
        self.category_filter = QComboBox()
        self.category_filter.currentIndexChanged.connect(self.filter_products)
        
        # Add New Product button
        add_product_btn = QPushButton("+ Ajouter un produit")
        add_product_btn.clicked.connect(self.add_product)
        add_product_btn.setStyleSheet("""
            QPushButton {
                background-color: #28a745;
                color: white;
                font-weight: bold;
                padding: 10px;
                border-radius: 5px;
            }
            QPushButton:hover {
                background-color: #218838;
            }
        """)
        
        # Add widgets to top layout
        top_layout.addWidget(search_label)
        top_layout.addWidget(self.search_input)
        top_layout.addWidget(category_label)
        top_layout.addWidget(self.category_filter)
        top_layout.addStretch()
        top_layout.addWidget(add_product_btn)
        
        main_layout.addLayout(top_layout)

        # Products table
        self.products_table = QTableWidget()
        self.products_table.setColumnCount(12)
        self.products_table.setHorizontalHeaderLabels([
            "ID", "Image", "Code-barres", "Nom", "Prix vente", "Prix achat", 
            "Stock", "Stock min", "Catégorie", "Variantes", "Marge", "Actions"
        ])

        # Set column widths
        self.products_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(2, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(3, QHeaderView.Stretch)
        self.products_table.horizontalHeader().setSectionResizeMode(4, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(5, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(6, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(7, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(8, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(9, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(10, QHeaderView.Fixed)
        self.products_table.horizontalHeader().setSectionResizeMode(11, QHeaderView.Fixed)
        
        self.products_table.setColumnWidth(0, 50)  # ID
        self.products_table.setColumnWidth(1, 70)  # Image
        self.products_table.setColumnWidth(2, 100) # Barcode
        # Column 3 (Name) is set to stretch
        self.products_table.setColumnWidth(4, 80)  # Sell price
        self.products_table.setColumnWidth(5, 80)  # Purchase price
        self.products_table.setColumnWidth(6, 60)  # Stock
        self.products_table.setColumnWidth(7, 60)  # Min stock
        self.products_table.setColumnWidth(8, 120) # Category
        self.products_table.setColumnWidth(9, 120) # Variants
        self.products_table.setColumnWidth(10, 80) # Margin
        self.products_table.setColumnWidth(11, 180) # Actions
        
        main_layout.addWidget(self.products_table)
        
        # Load categories for the filter
        self.load_categories()

    def load_categories(self):
        """Load categories for filtering"""
        self.category_filter.clear()
        self.category_filter.addItem("Toutes les catégories", None)
        
        categories = Category.get_all_categories()
        for category in categories:
            self.category_filter.addItem(category[1], category[0])

        def load_products(self, category_id=None):
        """Load products from database - FIXED version"""
        try:
            # Clear table
            self.products_table.setRowCount(0)
            
            # Get products directly with SQL
            from database import get_connection
            conn = get_connection()
            if not conn:
                print("Erreur de connexion à la base de données")
                return
                
            try:
                cursor = conn.cursor()
                
                # Direct SQL query
                if category_id:
                    cursor.execute("""
                        SELECT 
                            p.id, p.barcode, p.name, p.unit_price, p.purchase_price,
                            p.stock, p.min_stock, p.category_id, c.name as category_name,
                            p.image_path, p.has_variants, p.variant_attributes, p.description
                        FROM Products p
                        LEFT JOIN Categories c ON p.category_id = c.id
                        WHERE p.category_id = ?
                        ORDER BY p.name
                    """, (category_id,))
                else:
                    cursor.execute("""
                        SELECT 
                            p.id, p.barcode, p.name, p.unit_price, p.purchase_price,
                            p.stock, p.min_stock, p.category_id, c.name as category_name,
                            p.image_path, p.has_variants, p.variant_attributes, p.description
                        FROM Products p
                        LEFT JOIN Categories c ON p.category_id = c.id
                        ORDER BY p.name
                    """)
                
                # Get column names
                columns = [column[0] for column in cursor.description]
                
                # Fetch rows and convert to dictionaries
                products = []
                for row in cursor.fetchall():
                    product_dict = dict(zip(columns, row))
                    products.append(product_dict)
                
                print(f"Chargé {len(products)} produits depuis la base de données")
                
                # Set row count
                self.products_table.setRowCount(len(products))
                
                # Fill table
                for row, product_dict in enumerate(products):
                    try:
                        # Extract values with defaults
                        product_id = product_dict.get('id', 0)
                        unit_price = float(product_dict.get('unit_price', 0))
                        purchase_price = float(product_dict.get('purchase_price', 0))
                        stock = int(product_dict.get('stock', 0))
                        min_stock = int(product_dict.get('min_stock', 0))
                        
                        # Log for debugging
                        print(f"Affichage du produit: {product_dict['name']} (ID: {product_id})")
                        
                        # ID column
                        id_item = QTableWidgetItem(str(product_id))
                        id_item.setFlags(id_item.flags() & ~Qt.ItemIsEditable)  # Make read-only
                        self.products_table.setItem(row, 0, id_item)
                        
                        # Image column
                        image_label = QLabel()
                        image_label.setAlignment(Qt.AlignCenter)
                        
                        # Check if image exists
                        if product_dict.get('image_path') and os.path.exists(product_dict.get('image_path', '')):
                            pixmap = QPixmap(product_dict.get('image_path', ''))
                            if not pixmap.isNull():
                                scaled_pixmap = pixmap.scaled(
                                    60, 60,
                                    Qt.KeepAspectRatio,
                                    Qt.SmoothTransformation
                                )
                                image_label.setPixmap(scaled_pixmap)
                        
                        self.products_table.setCellWidget(row, 1, image_label)
                        
                        # Other columns
                        self.products_table.setItem(row, 2, QTableWidgetItem(str(product_dict.get('barcode', ''))))
                        self.products_table.setItem(row, 3, QTableWidgetItem(str(product_dict.get('name', ''))))
                        self.products_table.setItem(row, 4, QTableWidgetItem(f"{unit_price:.2f} MAD"))
                        self.products_table.setItem(row, 5, QTableWidgetItem(f"{purchase_price:.2f} MAD"))
                        
                        # Color stock cell based on min stock
                        stock_item = QTableWidgetItem(str(stock))
                        if stock <= min_stock:
                            stock_item.setBackground(Qt.red)
                            stock_item.setForeground(Qt.white)
                        self.products_table.setItem(row, 6, stock_item)
                        
                        self.products_table.setItem(row, 7, QTableWidgetItem(str(min_stock)))
                        self.products_table.setItem(row, 8, QTableWidgetItem(str(product_dict.get('category_name', ''))))
                        
                        # Variants info
                        has_variants = product_dict.get('has_variants', False)
                        variant_text = "Oui" if has_variants else "Non"
                        
                        if has_variants and product_dict.get('variant_attributes'):
                            try:
                                # Convert to list if it's a string
                                variant_attrs = None
                                if isinstance(product_dict['variant_attributes'], str):
                                    variant_attrs = json.loads(product_dict['variant_attributes'])
                                else:
                                    variant_attrs = product_dict['variant_attributes']
                                    
                                # Handle list or non-list data
                                if isinstance(variant_attrs, list):
                                    variant_text += f"\n({', '.join(variant_attrs)})"
                                elif isinstance(variant_attrs, dict):
                                    variant_text += f"\n({', '.join(variant_attrs.keys())})"
                                else:
                                    variant_text += "\n(Format inconnu)"
                            except Exception as e:
                                print(f"Error parsing variant attributes: {e}")
                                variant_text += "\n(Erreur de format)"
                        
                        self.products_table.setItem(row, 9, QTableWidgetItem(variant_text))
                        
                        # Profit margin
                        margin = 0
                        if purchase_price > 0:
                            margin = ((unit_price - purchase_price) / purchase_price) * 100
                        self.products_table.setItem(row, 10, QTableWidgetItem(f"{margin:.1f}%"))
                        
                        # Actions buttons
                        actions_widget = QWidget()
                        actions_layout = QHBoxLayout(actions_widget)
                        actions_layout.setContentsMargins(0, 0, 0, 0)
                        
                        stock_btn = QPushButton("📦")
                        variant_btn = QPushButton("🔄")
                        edit_btn = QPushButton("✏️")
                        delete_btn = QPushButton("🗑️")
                        
                        stock_btn.setToolTip("Gérer le stock")
                        variant_btn.setToolTip("Gérer les variantes")
                        edit_btn.setToolTip("Modifier le produit")
                        delete_btn.setToolTip("Supprimer le produit")
                        
                        # Connect buttons to actions
                        stock_btn.clicked.connect(lambda checked, p=product_dict: self.manage_stock(p))
                        edit_btn.clicked.connect(lambda checked, p=product_dict: self.edit_product(p))
                        delete_btn.clicked.connect(lambda checked, id=product_id: self.delete_product(id))
                        variant_btn.clicked.connect(lambda checked, p=product_dict: self.manage_variants(p))
                        
                        # Smaller button sizes
                        for btn in [stock_btn, variant_btn, edit_btn, delete_btn]:
                            btn.setMaximumWidth(40)
                            btn.setMaximumHeight(30)
                        
                        actions_layout.addWidget(stock_btn)
                        
                        if has_variants:
                            actions_layout.addWidget(variant_btn)
                            
                        actions_layout.addWidget(edit_btn)
                        actions_layout.addWidget(delete_btn)
                        actions_layout.addStretch()
                        
                        self.products_table.setCellWidget(row, 11, actions_widget)
                        
                    except Exception as e:
                        print(f"Error loading product row {row}: {e}")
                        print(f"Product data: {product_dict}")
                        import traceback
                        traceback.print_exc()
                        continue
            except Exception as e:
                print(f"Database error: {e}")
                import traceback
                traceback.print_exc()
            finally:
                if conn:
                    conn.close()
        except Exception as e:
            print(f"Error loading products: {e}")
            import traceback
            traceback.print_exc()
            from PyQt5.QtWidgets import QMessageBox
            QMessageBox.warning(self, "Erreur", f"Erreur lors du chargement des produits: {str(e)}")
def filter_products(self):
        """Filter products based on search text and category"""
        search_text = self.search_input.text().lower()
        category_id = self.category_filter.currentData()
        
        if category_id:
            # Filter by category first, then by search text
            self.load_products(category_id)
            
            # Then filter by search text
            for row in range(self.products_table.rowCount()):
                found = False
                for col in [2, 3]:  # barcode and name columns
                    item = self.products_table.item(row, col)
                    if item and search_text in item.text().lower():
                        found = True
                        break
                self.products_table.setRowHidden(row, not found)
        else:
            # Load all products and filter by search text
            self.load_products()
            
            # Then filter by search text
            for row in range(self.products_table.rowCount()):
                found = False
                for col in [2, 3]:  # barcode and name columns
                    item = self.products_table.item(row, col)
                    if item and search_text in item.text().lower():
                        found = True
                        break
                self.products_table.setRowHidden(row, not found)

    def add_product(self):
        """Open add product dialog"""
        try:
            from .add_product_dialog import AddProductDialog
            dialog = AddProductDialog(self)
            
            if dialog.exec_():
                self.load_products()
                QMessageBox.information(self, "Succès", "Produit ajouté avec succès!")
        except Exception as e:
            print(f"Error adding product: {e}")
            QMessageBox.warning(self, "Erreur", f"Erreur lors de l'ajout du produit: {str(e)}")

    def edit_product(self, product):
        """Open edit product dialog with enhanced error handling"""
        try:
            from ui.product_helpers import debug_log, get_product_by_id, handle_error
            
            debug_log(f"Opening edit dialog for product ID {product.get('id')}")
            
            # Reload product to ensure we have the most current data
            product_id = product.get('id')
            if product_id:
                fresh_product = get_product_by_id(product_id)
                if fresh_product:
                    product = fresh_product
                    debug_log(f"Successfully loaded fresh product data for ID {product_id}")
                else:
                    debug_log(f"Could not load fresh product data for ID {product_id}, using provided data")
            
            # Import dialog and show it
            from .edit_product_dialog import EditProductDialog
            dialog = EditProductDialog(product, self)
            
            if dialog.exec_():
                debug_log(f"Product {product_id} successfully edited, reloading product list")
                self.load_products()
                QMessageBox.information(self, "Succès", "Produit modifié avec succès!")
            else:
                debug_log(f"Edit dialog cancelled for product {product_id}")
                
        except Exception as e:
            debug_log(f"Error editing product: {e}")
            import traceback
            debug_log(traceback.format_exc())
            handle_error(self, "Erreur d'édition", "Impossible de modifier le produit", e)

    def delete_product(self, product_id):
        """Delete a product"""
        reply = QMessageBox.question(
            self, 'Confirmation',
            'Êtes-vous sûr de vouloir supprimer ce produit? Cette action est irréversible.',
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        
        if reply == QMessageBox.Yes:
            if Product.delete_product(product_id):
                self.load_products()
                QMessageBox.information(self, "Succès", "Produit supprimé avec succès!")
            else:
                QMessageBox.warning(self, "Erreur", "Erreur lors de la suppression du produit.")

    def manage_stock(self, product):
        """Open stock management dialog for a product"""
        try:
            # Import the dialog dynamically to avoid circular imports
            from .stock_management_dialog import StockManagementDialog
            
            # Create and show the dialog
            dialog = StockManagementDialog(product, self)
            
            if dialog.exec_():
                # Refresh the product list to show updated stock levels
                self.load_products()
        except Exception as e:
            print(f"Error opening stock management: {e}")
            QMessageBox.warning(
                self,
                "Erreur",
                f"Erreur lors de l'ouverture du gestionnaire de stock: {str(e)}"
            )
    
    def manage_variants(self, product):
        """Open the variant management dialog for an existing product"""
        try:
            # Import the dialog dynamically to avoid circular imports
            from .variant_management_dialog import VariantManagementDialog
            
            # Parse variant attributes if they exist
            variant_attributes = []
            if product.get('variant_attributes'):
                try:
                    if isinstance(product['variant_attributes'], str):
                        variant_attributes = json.loads(product['variant_attributes'])
                    else:
                        variant_attributes = product['variant_attributes']
                except Exception as e:
                    print(f"Error parsing variant attributes: {e}")
                    variant_attributes = []
            
            # Create and show the dialog
            dialog = VariantManagementDialog(
                product_id=product['id'],
                parent=self,
                variant_attributes=variant_attributes
            )
            
            if dialog.exec_():
                # Get the updated variant data
                variants_data = dialog.get_variants_data()
                
                # Update the product with the new variant data
                if variants_data:
                    # Update the product with new variant data
                    update_data = {
                        'has_variants': True,
                        'variant_attributes': json.dumps(dialog.get_attribute_names())
                    }
                    
                    # Update the product in the database
                    Product.update_product(product['id'], **update_data)
                    
                    # Update the variants
                    # Here we would need to add code to update/delete existing variants
                    # For now we'll just show a success message
                    self.load_products()
                    QMessageBox.information(
                        self,
                        "Succès",
                        f"{len(variants_data)} variantes configurées pour {product['name']}"
                    )
        except Exception as e:
            print(f"Error managing variants: {e}")
            QMessageBox.warning(
                self,
                "Erreur",
                f"Erreur lors de la gestion des variantes: {str(e)}"
            )
